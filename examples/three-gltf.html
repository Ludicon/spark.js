<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>three.js + spark.js GLTF loader example</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #111; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>

<body>
  <script type="module">
    import * as THREE from '../../three.js/build/three.webgpu.js';
    import { OrbitControls } from '../../three.js/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from '../../three.js/examples/jsm/loaders/GLTFLoader.js';
    import { RoomEnvironment } from '../../three.js/examples/jsm/environments/RoomEnvironment.js';

    import { Spark } from '../dist/index.esm.js';

    const errorHTML = `
      <div style="color: #FFF; padding: 2em; font-family: sans-serif; max-width: 600px; margin: 5em auto; text-align: center;">
        <h1>WebGPU Not Supported</h1>
        <p>This demo requires a browser with WebGPU support.</p>
        <p>Please try using <strong>Chrome</strong> or <strong>Edge</strong> with WebGPU enabled, or a recent version of <strong>Safari</strong> on macOS.</p>
        <p>More information: <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API" target="_blank">MDN: WebGPU API</a></p>
      </div>`;

    if (!navigator.gpu) {
      document.body.innerHTML = errorHTML;
      throw new Error('WebGPU not supported');
    }

    let adapter = null;
    try {
      adapter = await navigator.gpu.requestAdapter();
    } catch (err) {
      console.error("Error while requesting WebGPU adapter:", err);
    }
    if (!adapter) {
      document.body.innerHTML = errorMessage;
      throw new Error('No appropriate GPUAdapter found');
    }

    const requiredFeatures = Spark.getRequiredFeatures(adapter);
    const device = await adapter.requestDevice({ requiredFeatures });

    const canvas = document.createElement('canvas');
    document.body.appendChild(canvas);

    const context = canvas.getContext('webgpu');

    // Create WebGPU renderer with the given device:
    const renderer = new THREE.WebGPURenderer({ device, context, antialias: true })
    await renderer.init();

    // Create spark device
    const spark = await Spark.create(device);



    // Scene
    const scene = new THREE.Scene();

    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(2, 2, 3);

    // Controls
    const controls = new OrbitControls(camera, canvas);

    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(3, 5, 2);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff));

    // Environment map
    let pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    const neutralEnvironment = pmremGenerator.fromScene(new RoomEnvironment()).texture;
    scene.environment = neutralEnvironment;

    const Channel = {
      R: 1, // 0001
      G: 2, // 0010
      B: 4, // 0100
      A: 8, // 1000
      RG: 3, // 0011
      RGB: 7, // 0111
      RGBA: 15, // 1111
    };

    class GLTFSparkPlugin {

      constructor( parser, spark ) {
        this.name = 'spark';
        this.parser = parser;

        this.loaders = {
          [ 'rgba' ]: new SparkLoader( parser.fileLoader.manager, spark, 'rgba' ),
          [ 'rgba-srgb' ]: new SparkLoader( parser.fileLoader.manager, spark, 'rgba', THREE.SRGBColorSpace ),
          [ 'rgb' ]: new SparkLoader( parser.fileLoader.manager, spark, 'rgb' ),
          [ 'rgb-srgb' ]: new SparkLoader( parser.fileLoader.manager, spark, 'rgb', THREE.SRGBColorSpace ),
          [ 'rg' ]: new SparkLoader( parser.fileLoader.manager, spark, 'rg' ),
          [ 'r' ]: new SparkLoader( parser.fileLoader.manager, spark, 'r' ),
        };

        const textureCount = this.parser.json.textures?.length || 0;
        const textureColorSpaces = new Array( textureCount ).fill( THREE.NoColorSpace );
        const textureChannels = new Array( textureCount ).fill( 0 );

        for ( const materialDef of this.parser.json.materials ) {
          const baseColorTextureIndex = materialDef.pbrMetallicRoughness?.baseColorTexture?.index;
          if ( baseColorTextureIndex !== undefined ) {
            textureColorSpaces[ baseColorTextureIndex ] = THREE.SRGBColorSpace;
            textureChannels[ baseColorTextureIndex ] |= Channel.RGB;

            if ( materialDef.alphaMode == "MASK" || materialDef.alphaMode == "BLEND" ) {
              textureChannels[ baseColorTextureIndex ] |= Channel.A;
            }
          }

          const emissiveTextureIndex = materialDef.emissiveTexture?.index;
          if ( emissiveTextureIndex !== undefined ) {
            textureColorSpaces[ emissiveTextureIndex ] = THREE.SRGBColorSpace;
            textureChannels[ baseColorTextureIndex ] |= Channel.RGB;
          }

          const normalTextureIndex = materialDef.normalTexture?.index;
          if ( normalTextureIndex !== undefined ) {
            textureChannels[ baseColorTextureIndex ] |= Channel.RG;
          }

          const occlusionTextureIndex = materialDef.occlusionTexture?.index;
          if ( occlusionTextureIndex !== undefined ) {
            textureChannels[ baseColorTextureIndex ] |= Channel.R;
          }

          const metallicRoughnessTextureIndex = materialDef.metallicRoughnessTexture?.index;
          if ( metallicRoughnessTextureIndex !== undefined ) {
            textureChannels[ metallicRoughnessTextureIndex ] |= Channel.G | Channel.B;
          }
        }

        this.textureColorSpaces = textureColorSpaces;
        this.textureChannels = textureChannels;
      }

      loadTexture( textureIndex ) {
        const imageIndex = this.parser.json.textures[ textureIndex ].source;
        const colorSpace = this.textureColorSpaces[ textureIndex ];
        const channels = this.textureChannels[ textureIndex ];

        let format = 'rgba' // Default to 'rgba'
        if (channels == Channel.RGBA) {
          format = 'rgba' + (colorSpace === THREE.SRGBColorSpace ? "-srgb" : "");
        }
        else if ((channels & Channel.RGB) == channels) {
          format = 'rgb' + (colorSpace === THREE.SRGBColorSpace ? "-srgb" : "");
        }
        else if ((channels & Channel.RG) == channels) {
          format = 'rg';
        }
        else if ((channels & Channel.R) == channels) {
          format = 'r';
        }

        const loader = this.loaders[ format ];

        return this.parser.loadTextureImage( textureIndex, imageIndex, loader );
      }
    }

    class SparkLoader extends THREE.TextureLoader {

      constructor( manager, spark, format, colorSpace = THREE.NoColorSpace ) {
        super( manager );
        this.spark = spark;
        this.format = format;
        this.colorSpace = colorSpace;
      }

      load( url, onLoad, onProgress, onError ) {
        try {
          const format = this.format;
          const srgb = this.colorSpace === THREE.SRGBColorSpace;
          const mips = true;

          this.spark.encodeTexture( url, { format, srgb, mips } ).then( ( gpuTexture ) => {
            const texture = new THREE.ExternalTexture( gpuTexture );
            texture.colorSpace = this.colorSpace; // @@ IC: I don't think this makes any difference. Actually it appears that unless this is undefined, it's replaced with 'srgb'
            if (this.format == 'rg') {
              texture.projectZ = true;
            }
            onLoad( texture );
          } );

        } catch ( e ) {
          onError( e );
        }
      }
    }

    // Load GLTF
    const loader = new GLTFLoader();
    loader.register( ( parser ) => new GLTFSparkPlugin( parser, spark ) );
    const gltf = await loader.loadAsync( './assets/DamagedHelmet.glb' );
    //const gltf = await loader.loadAsync( './assets/FlightHelmet.gltf' );
    //const gltf = await loader.loadAsync( './assets/SciFiHelmet.gltf' );
    
    scene.add(gltf.scene);


    // Handle resize
    function resize() {
      const canvas = document.querySelector('canvas');
      if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };

    window.addEventListener('resize', resize);
    resize();

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

  </script>
</body>
</html>