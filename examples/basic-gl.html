<!doctype html>
<html>
  <!-- prettier-ignore -->
  <head>
    <title>spark.js WebGL example</title>
    <style>
      body { margin: 0; font-family: sans-serif; }
      canvas { display: block; }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
      }
      #error {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 2em;
        max-width: 600px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>

  <body>
    <canvas id="glCanvas"></canvas>
    <div id="info">
      <div>
        Format:
        <span id="format">-</span>
      </div>
      <div>
        Texture Size:
        <span id="size">-</span>
      </div>
      <div>
        Status:
        <span id="status">Initializing...</span>
      </div>
    </div>

    <script type="module">
      import { SparkGL } from "@ludicon/spark.js"

      function showError(message) {
        const errorDiv = document.createElement("div")
        errorDiv.id = "error"
        errorDiv.innerHTML = `
          <h1>Error</h1>
          <p>${message}</p>
        `
        document.body.appendChild(errorDiv)
      }

      function updateInfo(key, value) {
        const element = document.getElementById(key)
        if (element) {
          element.textContent = value
        }
      }

      async function init() {
        const canvas = document.getElementById("glCanvas")
        const gl = canvas.getContext("webgl2", {
          antialias: false,
          depth: false,
          stencil: false
        })

        if (!gl) {
          showError("WebGL2 is not supported. Please use a modern browser.")
          return
        }

        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

        // Create SparkGL instance
        updateInfo("status", "Creating SparkGL instance...")
        const spark = SparkGL.create(gl, { preload: ["rgb"], verbose: true })

        // Check supported formats
        const supportedFormats = spark.getSupportedFormats()
        console.log("Supported formats:", supportedFormats)

        if (supportedFormats.length === 0) {
          showError("No compressed texture formats are supported on this device. " + "Please try a different browser or device.")
          return
        }

        // Pick a format - prefer BC7 for desktop, ETC2 for mobile
        updateInfo("status", "Loading image...")

        // Load and encode texture
        const imageUrl = "./assets/kodim23.avif"
        let compressedTexture

        try {
          compressedTexture = await spark.encodeTexture(imageUrl, { format: "bc1-rgb" })
          updateInfo("size", `${compressedTexture.width}x${compressedTexture.height}`)
          updateInfo("format", compressedTexture.sparkFormatName)
          updateInfo("status", "Texture compressed!")
          console.log("Compressed texture:", compressedTexture)
        } catch (error) {
          showError(`Failed to compress texture: ${error.message}`)
          console.error(error)
          return
        }

        // Create a simple shader to display the compressed texture
        const vertexShaderSource = `#version 300 es
          in vec2 position;
          in vec2 texCoord;
          out vec2 vTexCoord;

          uniform vec2 uCanvasSize;
          uniform vec2 uTextureSize;

          void main() {
            vTexCoord.x = texCoord.x;
            vTexCoord.y = 1.0 - texCoord.y;

            // Scale to maintain aspect ratio
            float aspect = (uTextureSize.y * uCanvasSize.x) / (uCanvasSize.y * uTextureSize.x);
            vec2 scale = vec2(
              min(1.0, 1.0 / aspect),
              min(1.0, aspect)
            );

            gl_Position = vec4(position * scale, 0.0, 1.0);
          }
        `

        const fragmentShaderSource = `#version 300 es
          precision mediump float;
          in vec2 vTexCoord;
          out vec4 fragColor;

          uniform sampler2D uTexture;

          void main() {
            fragColor = texture(uTexture, vTexCoord);
          }
        `

        function compileShader(type, source) {
          const shader = gl.createShader(type)
          gl.shaderSource(shader, source)
          gl.compileShader(shader)

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compile error:", gl.getShaderInfoLog(shader))
            gl.deleteShader(shader)
            return null
          }

          return shader
        }

        const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource)
        const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource)

        const program = gl.createProgram()
        gl.attachShader(program, vertexShader)
        gl.attachShader(program, fragmentShader)
        gl.linkProgram(program)

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error("Program link error:", gl.getProgramInfoLog(program))
          return
        }

        // Create vertex buffer for a fullscreen quad
        // prettier-ignore
        const positions = new Float32Array([
          -1, -1, 0, 0, // bottom-left
          1, -1, 1, 0, // bottom-right
          -1, 1, 0, 1, // top-left
          1, 1, 1, 1 // top-right
        ])

        const vertexBuffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)

        const positionLoc = gl.getAttribLocation(program, "position")
        const texCoordLoc = gl.getAttribLocation(program, "texCoord")
        const canvasSizeLoc = gl.getUniformLocation(program, "uCanvasSize")
        const textureSizeLoc = gl.getUniformLocation(program, "uTextureSize")
        const textureLoc = gl.getUniformLocation(program, "uTexture")

        // Setup rendering
        function render() {
          gl.viewport(0, 0, canvas.width, canvas.height)
          gl.clearColor(0.1, 0.1, 0.1, 1.0)
          gl.clear(gl.COLOR_BUFFER_BIT)

          gl.useProgram(program)

          // Bind compressed texture
          gl.activeTexture(gl.TEXTURE0)
          gl.bindTexture(gl.TEXTURE_2D, compressedTexture.texture)
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
          gl.uniform1i(textureLoc, 0)

          // Set uniforms
          gl.uniform2f(canvasSizeLoc, canvas.width, canvas.height)
          gl.uniform2f(textureSizeLoc, compressedTexture.width, compressedTexture.height)

          // Setup vertex attributes
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
          gl.enableVertexAttribArray(positionLoc)
          gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 16, 0)
          gl.enableVertexAttribArray(texCoordLoc)
          gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 16, 8)

          // Draw
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
        }

        // Handle resize
        function resize() {
          canvas.width = window.innerWidth
          canvas.height = window.innerHeight
          render()
        }

        window.addEventListener("resize", resize)

        updateInfo("status", "Rendering...")
        render()
      }

      init().catch(error => {
        console.error("Initialization error:", error)
        showError(`Initialization failed: ${error.message}`)
      })
    </script>
  </body>
</html>
